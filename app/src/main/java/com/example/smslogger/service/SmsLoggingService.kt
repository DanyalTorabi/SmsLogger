package com.example.smslogger.service // Replace with your actual package name

import android.annotation.SuppressLint
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.content.ContentResolver
import android.content.Intent
import android.database.Cursor
import android.net.Uri
import android.os.Build
import android.os.IBinder
import android.provider.Telephony
import android.util.Log
import androidx.core.app.NotificationCompat
import com.example.smslogger.R
import com.example.smslogger.data.AppDatabase
import com.example.smslogger.data.SmsMessage
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch

class SmsLoggingService : Service() {

    private val TAG = "SmsLoggingService"
    private val NOTIFICATION_CHANNEL_ID = "SmsLoggerChannel"
    private val NOTIFICATION_ID = 1

    private var serviceJob = Job()
    private val serviceScope = CoroutineScope(Dispatchers.IO + serviceJob)

    // Note: Changed from lateinit to nullable and initialize in onCreate
    // to avoid potential issues if getDatabase is called very early.
    // Or, ensure AppDatabase.getDatabase is robust enough.
    // For simplicity, direct initialization in onCreate is fine.
    private lateinit var db: AppDatabase // Renamed from smsDao to db for clarity (it's the AppDatabase instance)

    override fun onCreate() {
        super.onCreate()
        db = AppDatabase.getDatabase(applicationContext) // Initialize AppDatabase instance
        Log.d(TAG, "Service Created")
        createNotificationChannel()
    }

    @SuppressLint("ForegroundServiceType")
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d(TAG, "Service Started")
        startForeground(NOTIFICATION_ID, createNotification())

        serviceScope.launch {
            logExistingSmsMessages()
        }
        return START_STICKY
    }

    private suspend fun logExistingSmsMessages() {
        Log.d(TAG, "Starting to log existing SMS messages...")
        val contentResolver: ContentResolver = applicationContext.contentResolver
        val smsUri: Uri = Telephony.Sms.CONTENT_URI
        val projection = arrayOf(
            Telephony.Sms._ID,
            Telephony.Sms.ADDRESS,
            Telephony.Sms.BODY,
            Telephony.Sms.DATE,
            Telephony.Sms.TYPE
        )

        val cursor: Cursor? = contentResolver.query(smsUri, projection, null, null, Telephony.Sms.DEFAULT_SORT_ORDER)

        cursor?.use {
            if (it.moveToFirst()) {
                val idColumn = it.getColumnIndexOrThrow(Telephony.Sms._ID)
                val addressColumn = it.getColumnIndexOrThrow(Telephony.Sms.ADDRESS)
                val bodyColumn = it.getColumnIndexOrThrow(Telephony.Sms.BODY)
                val dateColumn = it.getColumnIndexOrThrow(Telephony.Sms.DATE)
                val typeColumn = it.getColumnIndexOrThrow(Telephony.Sms.TYPE)

                val smsDao = db.smsDao() // Get DAO instance from AppDatabase

                do {
                    val smsIdFromProvider = it.getLong(idColumn) // Renamed for clarity
                    val address = it.getString(addressColumn)
                    val body = it.getString(bodyColumn)
                    val date = it.getLong(dateColumn)
                    val typeInt = it.getInt(typeColumn)

                    // Check if this SMS ID already exists in our database
                    val existingSms = smsDao.getSmsByOriginalId(smsIdFromProvider) // MODIFICATION HERE

                    if (existingSms == null) { // Only insert if it doesn't exist
                        val eventType = when (typeInt) {
                            Telephony.Sms.MESSAGE_TYPE_INBOX -> "RECEIVED"
                            Telephony.Sms.MESSAGE_TYPE_SENT -> "SENT"
                            Telephony.Sms.MESSAGE_TYPE_OUTBOX -> "OUTBOX"
                            Telephony.Sms.MESSAGE_TYPE_DRAFT -> "DRAFT"
                            Telephony.Sms.MESSAGE_TYPE_FAILED -> "FAILED"
                            Telephony.Sms.MESSAGE_TYPE_QUEUED -> "QUEUED"
                            else -> "UNKNOWN ($typeInt)"
                        }

                        val smsEntry = SmsMessage(
                            // id is auto-generated by Room
                            smsId = smsIdFromProvider, // Store the original Telephony.Sms._ID
                            smsTimestamp = date,
                            eventTimestamp = System.currentTimeMillis(),
                            phoneNumber = address ?: "Unknown",
                            body = body ?: "",
                            eventType = eventType
                        )

                        try {
                            smsDao.insertSms(smsEntry)
                            Log.d(TAG, "Logged NEW existing SMS: ProviderID $smsIdFromProvider, Type: $eventType")
                        } catch (e: Exception) {
                            Log.e(TAG, "Error saving new existing SMS (ProviderID: $smsIdFromProvider) to database", e)
                        }
                    } else {
                        Log.d(TAG, "Skipped existing SMS (already logged): ProviderID $smsIdFromProvider")
                    }

                } while (it.moveToNext())
                Log.d(TAG, "Finished processing existing SMS messages.")
            } else {
                Log.d(TAG, "No existing SMS messages found to log.")
            }
        } ?: run {
            Log.w(TAG, "Could not query SMS messages. Cursor is null.")
        }
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val serviceChannel = NotificationChannel(
                NOTIFICATION_CHANNEL_ID,
                "Sms Logger Service Channel",
                NotificationManager.IMPORTANCE_DEFAULT
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager?.createNotificationChannel(serviceChannel)
        }
    }

    private fun createNotification(): Notification {
        return NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
            .setContentTitle("Sms Logger Active")
            .setContentText("Logging SMS messages in the background.")
            .setSmallIcon(R.mipmap.ic_launcher)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .build()
    }

    override fun onBind(intent: Intent): IBinder? {
        return null
    }

    override fun onDestroy() {
        super.onDestroy()
        serviceJob.cancel()
        Log.d(TAG, "Service Destroyed")
    }
}
